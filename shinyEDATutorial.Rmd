---
title: "Shiny/EDA Tutorial"
author: "Ted Laderas"
date: "July 18, 2016"
output: pdf_document
---

##1.1 Our Goal For Today

The goal of today's workshop is to examine a set of genes across a number of cohorts for Dream Challenge Dataset. We will examine the subsetted data using the visualization framework built in R called Shiny and ask the question: Do we think there is enough signal in the exposure data to warrant further study of this dataset?

In order to do so, we'll first need to explore the data format and explore the data at two levels:

1. Single gene level (with multiple patients)
2. Aggregated pathway level ()

##1.2 Study Design

In this dataset for the [DREAM Respiratory Virus Challenge](https://www.synapse.org/#!Synapse:syn5647810) there are seven studies in total with the following characteristics. The most important is the Duke Rhinovirus dataset, which contained patients who were exposed to Rhinovirus (notated as `rhino`) and patients who were exposed to a control (annotated as `SHAM`).  We will only examine two of the studies: the Duke Rhinovirus study and the DEE3 H1N1 study (annotated as `DEE3 H1N1`).

![Study Design of Dataset](image/design.png)

Basically, for most of the timepoints and for most of the patients within a study, we have a microarray measurement. Note that some patients are missing certain timepoints, which complicates our analysis. 

The set of 20,000 probesets from the Affymetrix U133 2.0 microarray were mapped to the gene identifiers (in this case Gene Symbols) using the `hgu133plus2.db` annotation package and filtered using the following approach: Coefficients of Variation for the Sham (non exposed) patients at all timepoints were compared to the CVs for those patients exposed to Rhinovirus. The thought behind this is that genes of interest should show more variability (due to the time-series design) in the Rhinovirus patients than the sham patients.

Based on visualizing the distributions of CVs, a cutoff of `cvRhinovirus/cvSham` > 1.4 was used, leading to a set of 836 genes that had higher observed variability in the Rhinovirus compared to Shams. We'll be visualizing this much smaller set across multiple patients, diseases, and time points.

##1.3 Before You Get Started

Please make sure that you have the following packages installed before you proceed.

```{r eval=FALSE}
library(data.table)
library(ggplot2)
library(dplyr)
library(shiny)
```

Clone the repo into a directory. If you are using the GitHub desktop client, you will need to go to the webpage for the repo and select ">>Clone or Download >> Open in Desktop":

```{eval = FALSE}
git clone https://github.com/laderast/DreamEDAShiny
```

When you have cloned the repo, open the `DreamEDAShiny.Rproj` in RStudio (Use **File >> Open Project** to open it.)

#2.0 Examining the Rhinovirus Data

In this section, we'll examine the subsetted data in order to understand its format and learn some more about the `data.tables` package, which we'll use to store the data in memory. In case you are interested, there are a number of sections 

##2.1 Looking at the data objects

All of the data is in the `/data/twoStudies.RData` object. Let's look at the format of the data. Let's start by looking at the data objects in the `RData` file:

```{r}
#load the data up
library(data.table)
load('data/twoStudies.RData')

#list the objects
ls()
```

Look at the `viralData` table. How big is the data set (how many rows)? In what column is the expression value? Take a look at the `dataDescription.pdf` in the main directory of the repo. What do the other columns correspond to? What are our outcome variables that we want to examine?

```{r}
viralData
```

The `viralData` is in what's called `long` format, where each single observation (in this case, a microarray value for a probeset) is on its own line, accompanied by its metadata. This long format is what multiple packages, such as `dplyr` and `ggplot2` (which we use in this workshop) expect. We'll examine a method to `cast` (transform) the data into a `wide` matrix format later.

```{r}
#look at the averaged profiles
averageProfiles
```

How does the `averageProfiles` table differ from the `viralData` profile? What aspect of the data did we average over?

The last object we have in the `RData` file is the `pathways` object. This is a list of pathways from the Reactome database that the 836 genes 

```{r}
#show first 5
pathways[[1:5]]
```

##2.2 An Introduction to the `data.table` package

We are using the `data.tables` package to store the data in memory. There are many advantages of a `data.table` versus using the regular `data.frame`:

1. Subsetting and doing aggregate calculations (such as you would use `tapply()` for) are very fast for large datasets. This is because `data.table` avoids many of the memory-copying problems of current base R functions.
2. The `fread()` function to load in data in delimited files is very fast, much faster than the base function `read.table()`.
3. Joining tables is very fast and efficient.

The main disadvantage of `data.table` is that the syntax is different than for `data.frames` or `dplyr`. It is just different enough to drive you crazy.

##2.3 Keys For `data.table`

A `data.table` has a key, which you can set by using the `setkey()` function. This key is usually a column name, though you can also use multiple columns here. This key has two purposes: it provides an *index* to sort the `data.table`, and for joining with other tables, it provides the identifier to join on. Joins/merges with data.table are very quick.

```{r}
#make a data.table version of iris data
data(iris)

irisDT <- data.table(iris)

setkey(irisDT, Sepal.Length)
irisDT

```

##2.4 Merges/Joins of Two `data.tables` (Optional)

Let's specify another table to join `irisDT` on. 

```{r}
#make a little table to merge
#initializing a data.table is identical to initializing a data.frame
testTable <- data.table(Species=c("setosa", "versicolor", "virginica"), 
                        Likes=c(TRUE,FALSE,FALSE), Color = c("purple", "purple", "pink"))
#show the table
testTable
```


```{r}
setkey(irisDT, Species)
irisDT

setkey(testTable, Species)
```

Now that we have the keys set for both tables, we can join them together. In `data.table`, this is called a *rolling join*, and it is very fast, even for datasets with millions of rows. 

```{r}
#merge the two tables together using the keys we set (Species)
irisDT[testTable]
```

You may notice that the syntax here is completely different than `data.frame`. The way to read the above merge is that we want to merge the rows of `irisDT` and `testTable` given the keys that we have specified for each table.

###2.5 Casting the long data into wide data (Optional)

If we wanted the data in a `wide` matrix format with each row belonging to a probeset/patient/study triplet, and each column corresponding to the value of the time series, we can transform the data using `dcast`. This function lets us *reshape* the data into another format. 

The key to understanding `dcast` is understanding the formula interface for R, which works like this:

If we wanted 

```{r}
dcast(viralData, FEATUREID + SUBJECTID + STUDYID ~ TIMEHOURS, value.var= "value", fun.aggregate = mean)
```

###Subsetting Data

This operation is very fast, and is the main reason we're using `data.tables`. Let's look at the first entry in the `pathways` object.

```{r}
#get the name of the first list item
pway <- names(pathways)[1]
pway

path1 <- pathways[[pway]]
path1
```


###Calculating New Values on Columns



#3.0 Visualizing Gene Sets using Shiny

Now that we are familiar with the data format, let's start exploring the data set. Open the `global.R` file in the top folder and hit the "Run App" button in the top right corner of the script window to load the Shiny interface. 

##3.1 The 


##Discussion Time (Halfway Point)

What is your interpretation of the gene level versus pathway level? 

What did you get and not get from examining the data? 

What would you be interested in conditioning the plots on?

##Clustering The Data